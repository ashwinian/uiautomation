"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const events_1 = __importDefault(require("events"));
const utils_1 = require("./utils");
const suite_1 = __importDefault(require("./stats/suite"));
const hook_1 = __importDefault(require("./stats/hook"));
const test_1 = __importDefault(require("./stats/test"));
const runner_1 = __importDefault(require("./stats/runner"));
class WDIOReporter extends events_1.default {
    constructor(options) {
        super();
        this.options = options;
        if (this.options.outputDir) {
            fs_extra_1.default.ensureDirSync(this.options.outputDir);
        }
        this.outputStream = this.options.stdout || !this.options.logFile
            ? options.writeStream
            : fs_1.default.createWriteStream(this.options.logFile);
        this.failures = [];
        this.suites = {};
        this.hooks = {};
        this.tests = {};
        this.currentSuites = [];
        this.counts = {
            suites: 0,
            tests: 0,
            hooks: 0,
            passes: 0,
            skipping: 0,
            failures: 0
        };
        this.retries = 0;
        let currentTest;
        const rootSuite = new suite_1.default({
            title: '(root)',
            fullTitle: '(root)',
        });
        this.currentSuites.push(rootSuite);
        this.on('client:beforeCommand', this.onBeforeCommand.bind(this));
        this.on('client:afterCommand', this.onAfterCommand.bind(this));
        this.on('runner:start', (runner) => {
            rootSuite.cid = runner.cid;
            this.runnerStat = new runner_1.default(runner);
            this.onRunnerStart(this.runnerStat);
        });
        this.on('suite:start', (params) => {
            const suite = new suite_1.default(params);
            const currentSuite = this.currentSuites[this.currentSuites.length - 1];
            currentSuite.suites.push(suite);
            this.currentSuites.push(suite);
            this.suites[suite.uid] = suite;
            this.onSuiteStart(suite);
        });
        this.on('hook:start', (hook) => {
            const hookStat = new hook_1.default(hook);
            const currentSuite = this.currentSuites[this.currentSuites.length - 1];
            currentSuite.hooks.push(hookStat);
            currentSuite.hooksAndTests.push(hookStat);
            this.hooks[hook.uid] = hookStat;
            this.onHookStart(hookStat);
        });
        this.on('hook:end', (hook) => {
            const hookStat = this.hooks[hook.uid];
            hookStat.complete(utils_1.getErrorsFromEvent(hook));
            this.counts.hooks++;
            this.onHookEnd(hookStat);
        });
        this.on('test:start', (test) => {
            test.retries = this.retries;
            currentTest = new test_1.default(test);
            const currentSuite = this.currentSuites[this.currentSuites.length - 1];
            currentSuite.tests.push(currentTest);
            currentSuite.hooksAndTests.push(currentTest);
            this.tests[test.uid] = currentTest;
            this.onTestStart(currentTest);
        });
        this.on('test:pass', (test) => {
            const testStat = this.tests[test.uid];
            testStat.pass();
            this.counts.passes++;
            this.counts.tests++;
            this.onTestPass(testStat);
        });
        this.on('test:fail', (test) => {
            const testStat = this.tests[test.uid];
            testStat.fail(utils_1.getErrorsFromEvent(test));
            this.counts.failures++;
            this.counts.tests++;
            this.onTestFail(testStat);
        });
        this.on('test:retry', (test) => {
            const testStat = this.tests[test.uid];
            testStat.fail(utils_1.getErrorsFromEvent(test));
            this.onTestRetry(testStat);
            this.retries++;
        });
        this.on('test:pending', (test) => {
            test.retries = this.retries;
            const currentSuite = this.currentSuites[this.currentSuites.length - 1];
            currentTest = new test_1.default(test);
            if (test.uid in this.tests && this.tests[test.uid].state !== 'pending') {
                currentTest.uid = test.uid in this.tests ? 'skipped-' + this.counts.skipping : currentTest.uid;
            }
            const suiteTests = currentSuite.tests;
            if (!suiteTests.length || currentTest.uid !== suiteTests[suiteTests.length - 1].uid) {
                currentSuite.tests.push(currentTest);
                currentSuite.hooksAndTests.push(currentTest);
            }
            else {
                suiteTests[suiteTests.length - 1] = currentTest;
                currentSuite.hooksAndTests[currentSuite.hooksAndTests.length - 1] = currentTest;
            }
            this.tests[currentTest.uid] = currentTest;
            currentTest.skip(test.pendingReason);
            this.counts.skipping++;
            this.counts.tests++;
            this.onTestSkip(currentTest);
        });
        this.on('test:end', (test) => {
            const testStat = this.tests[test.uid];
            this.retries = 0;
            this.onTestEnd(testStat);
        });
        this.on('suite:end', (suite) => {
            const suiteStat = this.suites[suite.uid];
            suiteStat.complete();
            this.currentSuites.pop();
            this.onSuiteEnd(suiteStat);
        });
        this.on('runner:end', (runner) => {
            rootSuite.complete();
            this.runnerStat.failures = runner.failures;
            this.runnerStat.retries = runner.retries;
            this.runnerStat.complete();
            this.onRunnerEnd(this.runnerStat);
        });
        this.on('client:beforeCommand', (payload) => {
            if (!currentTest) {
                return;
            }
            currentTest.output.push(Object.assign(payload, { type: 'command' }));
        });
        this.on('client:afterCommand', (payload) => {
            if (!currentTest) {
                return;
            }
            currentTest.output.push(Object.assign(payload, { type: 'result' }));
        });
    }
    get isSynchronised() {
        return true;
    }
    write(content) {
        this.outputStream.write(content);
    }
    onRunnerStart() { }
    onBeforeCommand() { }
    onAfterCommand() { }
    onScreenshot() { }
    onSuiteStart() { }
    onHookStart() { }
    onHookEnd() { }
    onTestStart() { }
    onTestPass() { }
    onTestFail() { }
    onTestRetry() { }
    onTestSkip() { }
    onTestEnd() { }
    onSuiteEnd() { }
    onRunnerEnd() { }
}
exports.default = WDIOReporter;
